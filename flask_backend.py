# -*- coding: utf-8 -*-
"""flask_backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yEGLmmJmtr2H8xGf63jJgC8nI54bofdB
"""

!pip install --upgrade torch torchvision torchaudio
!pip install --upgrade transformers
!pip install --upgrade transformers-interpret

!pip install pyngrok

!pip install flask-cors

from flask import Flask, request, jsonify
from transformers import AutoModelForSequenceClassification, AutoTokenizer
import torch
from transformers_interpret import SequenceClassificationExplainer
from pyngrok import ngrok
from flask_cors import CORS

# Inisialisasi Flask
app = Flask(__name__)
CORS(app)

# Load model dan tokenizer
MODEL_NAME = "namoklom/IndoBERT-Hoax-Detection"
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = AutoModelForSequenceClassification.from_pretrained(MODEL_NAME)
tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)
model.to(device)
explainer = SequenceClassificationExplainer(model, tokenizer)

# Konstanta
MAX_TOKENS = 50

# 🔍 Endpoint untuk prediksi berita
@app.route('/predict', methods=['POST'])
def predict():
    try:
        data = request.get_json(force=True)
        text = data.get('text', '').strip()
        if not text:
            return jsonify({"error": "Text field is empty"}), 400
    except Exception:
        return jsonify({"error": "Invalid JSON body"}), 400

    # Potong jika terlalu panjang
    words = text.split()
    if len(words) > MAX_TOKENS:
        text = " ".join(words[:MAX_TOKENS])

    # Tokenisasi
    inputs = tokenizer(
        text,
        max_length=MAX_TOKENS,
        truncation=True,
        padding='max_length',
        return_tensors="pt"
    )
    inputs = {k: v.to(device) for k, v in inputs.items()}

    try:
        with torch.no_grad():
            outputs = model(**inputs)
            probs = torch.nn.functional.softmax(outputs.logits, dim=1)
            predicted_class = torch.argmax(probs).item()
            confidence = float(torch.max(probs).item())
    except Exception as e:
        return jsonify({"error": f"Model prediction failed: {str(e)}"}), 500

    try:
        keywords = [{"word": w, "score": float(s)} for w, s in explainer(text)]
    except Exception as e:
        keywords = []
        print(f"[Explainer Error] {e}")

    return jsonify({
        "prediction": predicted_class,
        "confidence": probs.squeeze().cpu().tolist(),
        "keywords": keywords
    })

# 🚀 Jalankan Flask + Ngrok
if __name__ == '__main__':
    ngrok.set_auth_token("2ioj4nEfQquML4tpWLN7wkDGhv4_4RUi4wtgQfNdiutZjXQ7Y")
    public_url = ngrok.connect(5000).public_url
    print(f" * Public URL: {public_url}")
    app.run(host="0.0.0.0", port=5000)